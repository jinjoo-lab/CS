# GC (1)

### 서론

> GC는 Java를 공부하는데 있어 정말 근본중의 근본이다. 하지만 깊게 기술한 책은 찾기 힘들고 블로그는 대부분 특정 깊이까지만 ( 면접 대비 용 ) 다룬다. 하지만 **JVM 밑바닥까지 파헤치기**라는 정말 좋은 도서가 세상에 나왔고 GC 부분에 대해 깊이 있게 기술해놨다. 이 도서와 다양한 자료를 바탕으로 깊이 있게 학습하고 내용을 공유하고자 한다.
>

### 동적 메모리 할당

- Java에서 객체의 인스턴스는 **Heap 영역에서 관리**된다. 세부적으로는 new 키워드를 통해 생성한 인스턴스에 대해 동적으로 메모리를 할당한다.

**C 계열과의 차이**

> C계열의 언어를 사용해보면 알겠지만 **malloc**과 **free**라는 키워드를 통해 **동적으로 메모리를 할당**하고 **해제**가 가능하다. 하지만 Java에는 사용자가 직접 할당했던 **특정 메모리를 회수하는(free) 명령어**는 존재하지 않는다.
>
- 즉 code level에서 동적으로 할당한 메모리를 관리하지 않는다.

### 동적 메모리 관리 기법

> Heap 영역에 대해 메모리를 관리하는 기법에는 여러 가지가 있다. Java에서는 자동적으로 동적 메모리를 관리하는 **GC 기법**을 사용한다.
>

### GC

> 프로그램이 **동적으로 할당된 메모리 영역**에 대하여 **자동으로 메모리를 해제**하는 기법
>
- 장점
    - 개발자가 수동적으로 관리하던 메모리를 프로그램에 제어권을 넘겨 오류를 막을 수 있다. (누수 또한 막을 수 있다)
- 단점
    - GC 작업은 순수 오버헤드가 큰 작업이다.
    - 개발자가 GC 타이밍에 대해 알 수 없다. ( System.gc 를 사용하는 것이 아니라면 )

---

### JVM Memory

> JVM Runtime Memory를 우리는 논리적으로 5개로 구분했다. 그렇다면 5개의 논리적 영역 중 어느 영역이 GC의 대상일까?
>

**프로그램 카운터, 스택, 네이티브 메서드 스택** VS **힙, 메서드**

> 위 구분 기준은 메모리 영역의 생명 주기에 따른 것이다. 앞의 3개의 영역은 사용자 쓰레드가 할당되면 생성되고 뒤의 2개의 영역은 JVM이 시작되면 생성된다.
>
- 즉 앞서 3개의 영역은 메모리 할당과 회수가 고정적(쓰레드의 생성과 파괴)이기 때문에 관리 대상이 아니다.
- 하지만 JVM이 실행되는 동안 유지되는 **힙 영역과 메서드 영역은 GC의 대상**이다.

### 메서드 영역이 GC 대상이라고?

> 정확히 말하자면 GC 대상으로 허용할 수 도 있고 아닐 수 도 있다.
>
- Heap 영역에 비해 메서드 영역은 회수 조건이 까다로워 효율이 떨어진다.
- 메서드 영역의 회수 대상은 ‘상수’와 ‘클래스’이다.
    - **상수에 대한 판단**은 Heap 영역의 인스턴스 GC 판단과 비슷하다.
    - 하지만 **클래스에 대한 회수 판단**은 굉장히 까다롭다.
        - Java Heap에 **해당 클래스와 상속 구조의 하위 클래스의 인스턴스가 한 개도 존재해서는 안된다.**
        - 해당 **클래스을 읽어 들인 클래스 로더가 회수**되었다.
        - 해당 클래스에 대한 **java.lang.Class 객체를 어디서도 참조하지 않고**, **리플렉션 기능을 이용**하는 곳도 없다.

> 핫스팟 가상 머신은 3 조건에 부합하는 클래스들을 회수하도록 허용한다. (즉 반드시 회수되는 것은 아니다)
**매개 변수(-Xnoclassgc)를 통해 클래스 회수 여부를 가능**하게 할 수 있다.
>

---

# Garbage Collector

### GC 대상이란 무엇일까?

- 굉장히 근본적인 의문이다.

> GC 대상이란 기본적으로 **Heap 영역의 인스턴스**를 의미한다. 하지만 모든 인스턴스가 GC의 대상으로 선정되는 것은 아니다. 즉 객체의 생존 여부를 판단하고 **죽은 객체를 GC의 대상**으로 선정해야 한다.
>

**죽은 객체**

> 포괄적인 의미로 **모든 참조(연결)이 끊긴 객체**를 의미한다. 하지만 GC 알고리즘에 따라 좀 더 세부적인 정의가 필요하고 이는 각 알고리즘을 기술하면서 설명하겠다.
>

## 참조 카운팅 알고리즘 (Reference Counting)

- 객체에 해당 객체를 가리키는 **참조 카운터를 추가**한다
    - 참조가 증가할 때마다 해당 카운터의 값을 1씩 증가한다.
    - 반대로 해당 인스턴스에 대한 참조가 끊길 때마다 1씩 카운터의 값을 감소시킨다.
- **카운터의 값이 0이 된 객체를 죽은 객체**라 판단하고 GC의 대상으로 지정한다.

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled.png)

### 장점

1. 약간의 메모리 사용을 통해 **GC 대상에 대한 판단**을 빠르게 가져갈 수 있다.
2. **stop-the-world**에 대한 **시간이 분산**되어 실시간 작업에 대해 영향이 적다.

### 단점

**순환 참조의 문제**

> A → B, B → A의 경우가 있다고 생각하자. 그리고 두 객체의 참조를 해제하더라도 외부의 접근은 불가능하나 counter의 값이 1이기 때문에 GC의 대상으로 지정할 수 없다.
>

```java
public class MyGC {
    public static void main(String[] args) {
        GcPoint A = new GcPoint();
        GcPoint B = new GcPoint();
        
        A.instance = B;
        B.instance = A; // 순환 참조 생성
        
        A = null;
        B = null; // A,B 객체의 참조를 끊는다.
        
        /*
        * Reference Counting 알고리즘의 경우 아직 Counter 값이 1이라 
        * 더 이상 접근이 불가능하지만 삭제되지 않는다.
        * */
    }
}
class GcPoint {
    GcPoint instance;
    
    GcPoint() {}
}
```

## 도달 가능성 분석 알고리즘

> Java의 경우 GC 대상 판단을 위해서 **참조 카운팅 알고리즘**이 아닌 **도달 가능성 분석 알고리즘**을 사용한다.
>
- **GC 루트**라고 하는 **루트 객체들을 시작 노드 집합**으로 사용
    - GC 루트로부터 출발하여 참조하는 다른 객체들로 탐색 (경로를 참조 체인이라 부른다)

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%201.png)

**죽은 객체**

> GC 루트 사이를 이어 주는 참조 체인이 없다면, **GC 루트로부터 도달 불가능한 객체**는 죽은 객체로 판단
>
- **GC 루트로 이용할 수 있는 객체**
    - **스택 프레임의 지역 변수 테이블**에서 참조하는 객체
    - 메서드 영역에서 **정적 필드 or 상수로 참조**하는 객체
    - **네이티브 메서드 스택에서 JNI가 참조**하는 객체
    - **동기화 락으로 잠겨 있는 개체**

## 참조의 구분

> JDK 1.2 전의 자바에서는 ‘참조’를 이분법 적으로 기술하였다. 하지만 1.2부터 참조를 4가지 기준으로 나눴는데 이를 이해하는 것이 GC에도 도움이 되기 때문에 짚고 넘어가겠다.
>

| 강한 참조 | soft 참조 | weak 참조 | phantom 참조 |
| --- | --- | --- | --- |

### 강한 참조 (Strong Reference)

> 전통적인 정의의 참조 **ex) Object obj = new Object()**
>
- 프로그램 코드에서 참조를 할당하는 것 ( **강한 참조 관계**가 남아 있는 객체는 **GC가 절대 회수하지 않는다.** )

### Soft 참조 (Soft Reference)

> 유용하지만 필수는 아닌 객체
>
- **JVM 메모리가 부족**하면 (오버 플로 발생 직전) 두 번째 회수를 위한 회수 목록에 추가
    - SoftReference 객체만 존재하는 경우

```java
MyGC ref = new MyGC();      

SoftReference<MyGC> softRef = new SoftReference<MyGC>(ref); 

ref = null;

// JVM의 메모리가 부족하지 않아 GC 실행 대상이 되지 않은 경우 + soft 참조가 남아 있는 경우 객체 반환
ref = softRef.get();
```

### Weak 참조 (Weak Reference)

> soft 참조보다 연결 강도가 더 약한 객체
>
- **GC가 동작**한다면 **JVM 메모리가 여유**있더라도 **weak 참조된 객체는 모두 회수**된다.

```java
MyGC ref = new MyClass();      

WeakReference<MyGC> weakRef = new WeakReference<MyGC>(ref); 

ref = null;

// 다음 GC 실행시 무조건 힙 메모리에서 제거
ref = weakRef.get();
```

### Phantom 참조 (Phantom Reference)

> **객체 수명에 영향을 주지 않으며** **객체 인스턴스조자 가져오지 못하는** 가장 약한 형태의 참조
>

# Heap Memory

> GC가 수행되는 위치는 Heap 메모리이다. 그리고 JVM에서는 Heap을 내부적으로 더 상세하게 구분해놨는데 이를 이해하는 것이 중요하다.
>

### 세대 단위 컬렉션 이론

> 현재 대부분 JVM GC는 **세대 단위 컬렉션 이론에 기초해 설계**되었다.
>
1. **약한 세대** 가설 : 대다수의 객체의 수명은 짧다.
2. **강한 세대** 가설 : GC를 거듭하여 살아남은 객체일수록 더 오래 살아남을 가능성이 높다.

> 위 두 가설에 기초하여 힙 영역을 구분한다. **나이(얼마나 GC과정에서 살아남았는가)**를 통해 객체를 서로 다른 영역에 배치
>

### Young & Old

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%202.png)

- **Young Generation**
    - 새로운 객체들이 생성되는 곳 → 수명이 짧은 객체들은 Young Generation에서 할당이 해제된다.
    - Young Generation에서 수행되는 GC를 **Minor GC**라고 한다.
- **Old Generation**
    - GC를 여러번 거쳐 살아남은 객체들이 배치되는 영역
    - Old Generation에서 수행되는 GC를 **Major GC**라고 한다.

**왜 구분하는가 ?**

> 대부분의 객체들을 모아놓고 관리하여 살아남은 객체들을 따로 유지하여 영역 회수에 드는 시간과 공간의 유리함을 가져가기 위해서이다.
>

## Young의 세부 구분

> Heap 영역의 효율적인 사용을 위해 **Young 영역**을 **Eden, Survivor 0, Survivor 1** 3가지 영역으로 또 나눈다. (이것을 아펠 스타일 컬렉션 방식이라 한다.)
>

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%203.png)

### Eden

> **new를 통해 새롭게 생성된 객체**가 위치한다.
>
- Eden 영역에 객체가 차게 되면 Minor GC 과정을 통해 살아남은 객체를 Survivor 영역으로 보내게 된다.

### Survivor 0 / Survivor 1

> **최소 1번의 GC를 살아남은 객체**가 위치
>
- Survivor 0나 Survivor 1 **두 영역 중 하나의 영역은 반드시 비어 있어야 한다 !**

**왜 둘 중 하나를 비어놓을까 ?**

> 두 영역 중 **하나만 가용**하여 GC가 발생할 때마다 **객체의 복사를 쉽게 수행**하기 위해서이다.
>
- GC가 일어날 때마다 살아남은 객체와 죽은 객체를 표시하여 **하나의 공간에서 비우게 된다면**
    - 메모리 파편화가 심해진다.
    - 객체가 많아질수록 실행 효율이 떨어지는 구조이다.
- 즉 **메모리를 일정 포기**하고 **GC 작업에 있어 효율을 가져가는 것**이다.

## Minor GC

> Young Generation에서 수행되는 GC
>
- 대부분의 객체는 생성 후 곧바로 사라지기 때문에 **Mark - Copy** 알고리즘을 사용한다.
- Major GC에 비해 수행 시간이 적다. → stop - the - world의 영향이 작다

### 수행 과정

1. 처음 생성된 객체들은 **Eden 영역에 배치**된다.

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%204.png)

1. Eden 영역이 차게 된다면 **Minor GC**가 실행된다.
    - Mark 과정을 통해 회수될 인스턴스를 모두 표시 ( 판단은 **도달 가능성 판단 알고리즘** )
    - Eden 영역에서 살아남은 객체들은 2중 하나의 Survivor 영역으로 이동
        - 살아남은 **객체들의 age값을 1씩 증가**
    - 도달 불가능한 객체들은 지워버린다. (기본적으로 mark - copy다)

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%205.png)

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%206.png)

## Major GC

> Old Generation에서 수행되는 GC
>
- Minor GC가 수행될수록 살아남게 된 객체들의 age 값은 증가하게 된다. 이 값이 **특정 치에 도달하게 되면 객체들은 survivor 영역에서 old 영역으로 이동**하게 된다.
- Major GC는 Old 영역이 가득차게 되면 수행되는 GC인 것이다.

### 수행 과정

1. Survivor 영역에서 **age가 특정 값에 도달한 객체**들을 Old 영역으로 이동 : **Promotion**

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%207.png)

1. Old Generation이 가득차게 되면 **Major GC**가 발생

![Untitled](GC%20(1)%2037fff5ee187d4d8c9e3ff2bd93921c8d/Untitled%208.png)

- Major GC는 기본적으로 Mark-Sweep 방식을 통해 수행된다. 즉 도달 가능성이 끊긴 객체들을 지우는 것이다.

### stop - the - world

> GC를 수행하기 위해 JVM이 **모든 애플리케이션 실행을 멈추는 것**
>
- GC를 수행하는 쓰레드를 **제외한 모든 쓰레드가 중지**된다.
- 즉 GC의 효율을 높이는 것은 stop-the-world를 최적화하는 것이다.
