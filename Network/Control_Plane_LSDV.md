# Control Plane ( LS , DV )

## 네트워크 계층 (제어 평면)

### 라우팅

> 출발지 호스트로부터 목적지 호스트까지 전달되는 **패킷 경로 설정**
>
- 패킷 경로 설정
    - (라우팅 알고리즘) 포워딩 테이블을 계산하고 갱신하여 최적의 경로를 위한 정보를 제공하는 것이다.

### 포워딩 테이블을 설정 + 유지

- **라우터별** 제어
- **논리형 중앙집중형** 제어

**라우터별 제어**

> 각각의 라우터에서 라우팅 알고리즘 수행
>
- 개별 라우터에 **포워딩**과 **라우팅** 기능이 포함되어 있다.
- 각 라우터는 다른 라우터와 통신하여 자신의 포워딩 테이블의 값 계산 (각 라우터 간의 상호작용)
- Ex) OSPF , BGP

**논리형 중앙집중형 제어**

> **논리형 중앙 집중형 컨트롤러**가 포워딩 테이블을 계산하고 개별 라우터에게 배포
>
- 컨트롤러는 각 라우터의 CA (제어 에이전트)와 상호작용 → 플로우 테이블 구성 및 관리
    - CA는 통신 및 명령 수행 등 최소한의 기능만 가진다.
- Ex) SDN

## 라우팅 알고리즘

> 송신자부터 수신자까지 라우터의 네트워크를 통과하는 **패킷의 최적 경로를 계산**하는 알고리즘
>
- 최적 경로란 ?
    - 최소 비용 + 최소 거리의 개념을 모두 내포하고 있다.
- 라우팅 문제는 **그래프의 개념**으로 기술할 수 있다.

### 그래프

> G(N,E) 로서 Node와 Edge의 집합
>
- 구성요소
    - Node : 라우터 , (BGP에서는 하나의 네트워크)
    - Edge : 물리 링크 , (BGP에서는 두 네트워크간의 연결 즉 피어링)

## 분류

### 중앙 집중형 & 분산형

---

**중앙 집중형** 라우팅 알고리즘

> **네트워크 전체에 대한 완전한 정보**를 가지고 출발지와 목적지 사이의 최소 비용 경로 계산
>
- 완전한 정보
    - 모든 노드 사이의 연결 상태 + 링크 비용
    - SDN에서 수행되거나 모든 라우터의 모듈로 복사
- **링크 상태(LS) 알고리즘**

**분산** 라우팅 알고리즘

> 최소 비용 경로의 계산이 라우터들에 의해 **반복적**이고 **분산**된 방식으로 수행
>
- 직접 정보
    - 각 노드는 자신에게 직접 연결된 비용에 대한 정보만을 가짐
- **거리 벡터(DV) 알고리즘**

### 정적 & 동적

---

**정적** 라우팅 알고리즘

- 경로의 갱신이 느리게 동작한다. + 사람의 직접 개입

**동적** 라우팅 알고리즘

- 네트워크 트래픽 부하 / 토폴로지 변화에 따라 라우팅 경로가 변함
    - 네트워크 변화에 빠르게 대응
    - 경로의 루프나 진동 문제 가능

### 부하에 따른 분류

---

- 부하에 민감하다면 **링크 비용은 혼잡 수준을 나타내기 위해 동적으로 변한다.**
    - 혼잡 → 링크 비용을 높임 : 경로 우회
    - OSPF , BGP는 링크 비용이 즉각적 혼잡을 반영하지는 않는다.

## LS(링크 상태) 알고리즘

---

> 네트워크 토폴로지와 링크 비용에 대한 정보가 알려져 있다. → 알고리즘의 입력값으로 사용
>
- **How ?**

  각 노드가 자신과 직접 연결된 링크의 식별자와 비용 정보를 담은 **링크 상태 패킷**을 네트워크 상의 모든 노드로 **브로드캐스트**

- OSPF와 같은 링크 상태 브로드캐스트 알고리즘에 의해 수행

### 다익스트라 알고리즘

> 하나의 노드에서 네트워크 내에 다른 모든 노드까지의 최소 비용 경로 계산 알고리즘
>
- 시간 복잡도 : **O(N^2)** / **O(NlogN)** : 힙 자료구조 사용
- 기본 정의
    - D(v) : 출발지로부터 도착지까지의 최소 비용 경로
    - p(v) : 최소 비용 경로에서 v의 직전 노드
    - N’ : 노드의 집합 ( 최소 비용 경로를 찾은 )
- **초기화** + **반복** 부분으로 구성
    - 반복 부분은 노드의 수인 N번 반복
    - 초기화
        - 출발지로부터 **직접 연결된 이웃**까지 알려진 **최소 비용 경로** 초기화 (직접 연결)
    - 반복
        - **직전 최소 비용 경로를 찾은 노드**에서 추가적 최소 비용 경로 계산

### 진동 문제 ( Oscillation )

> **네트워크의 토폴로지가 변경**되었을 때, 라우터들이 계속해서 **최단 경로를 재계산**하고 이로 인해 라우팅 테이블이 **계속해서 업데이트**되는 현상
>
- 혼잡이나 지연 시간을 기반으로 링크 비용을 산출하는 모든 알고리즘에서 발생 가능
- 다익스트라 알고리즘의 경우 매번 최소 비용 경로를 선택하기 위해 네트워크에 변화에 민감하게 반응하고 결과적으로 진동 문제 발생 가능

```
   A
  / \
 B - C
  \ /
   D 

A -> B ( 1 )
A -> C ( 2 )
```

1. 네트워크 토폴로지 변화 ( B와 C 사이의 링크 상태 변화 → 비용 증가 )
2. 다익스트라 알고리즘 재수행 → 최단 경로 다시 계산
3. A는 B → C → D 경로를 새로운 가중치를 반영하여 계산
4. B는 A → D로 가는 경로를 바탕으로 다시 계산
- **진동 문제 !!!!**
    - A와 B는 서로에게 영향을 주고 받으면서 계속해서 최단 경로를 계산하고 라우팅 테이블을 갱신
    - 계속 반복되면 네트워크는 계속해서 라우팅 테이블을 갱신

해결책

- 링크 비용이 **해당 링크가 전달하는 트래픽 양에 의존하지 않도록** 한다.
    - 하지만 혼잡 정보를 반영하지 않는다는 것은 역설적이다.
- 모든 라우터가 **동시에 링크 상태 알고리즘을 수행하지 않도록 한다. (주기 제어)**

> 라우터들은 결국 동기화된다. 자기 동기화는 링크 상태 정보를 송신 시각을 임의로 결정하게 함
>

## DV(거리 벡터) 알고리즘

---

> 최소 비용 경로의 계산을 라우터들에 의해 **반복적**이고 **분산**된 방식으로 수행
>
- **반복적** + **비동기적** + **분산적**
- 분산적
    - 각 노드는 직접 연결된 이웃으로부터 정보를 받고 계산하여 다시 전달한다.
- 반복적
    - 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속
- 비동기적
    - 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다.

### 벨만 포드(Bellman-Ford) 알고리즘

$$
dx(y)  = minv(c(x,y) , dv(y))
$$

- minv값은 모든 이웃에게 적용된다.
- 기본 정의
    - c(x,y) : 각 이웃 노드 v 중에서 x에 **직접 연결된 노드**까지 비용
    - Dx : 노드 x까지의 거리 벡터 (비용 예측값 포함)

> 노드 x의 거리 벡터가 변경된다면 수정된 거리 벡터를 이웃에게 전달 , 이웃은 자신의 거리 벡터 갱신
>

### 동작 방식

![Untitled](Control%20Plane%20(%20LS%20,%20DV%20)%200fc463fc1aaf4c0fa3d18ca9e0ebd4c5/Untitled.png)

1. 초기 상태 : 직접 연결된 비용만 가지고 있음

![Untitled](Control%20Plane%20(%20LS%20,%20DV%20)%200fc463fc1aaf4c0fa3d18ca9e0ebd4c5/Untitled%201.png)

1. 각 출발 노드는 이웃에 대해 최소 거리 갱신 → 상태를 이웃에게 전달

![Untitled](Control%20Plane%20(%20LS%20,%20DV%20)%200fc463fc1aaf4c0fa3d18ca9e0ebd4c5/Untitled%202.png)

1. 이웃은 전달 받은 정보를 바탕으로 거리 벡터 갱신

![Untitled](Control%20Plane%20(%20LS%20,%20DV%20)%200fc463fc1aaf4c0fa3d18ca9e0ebd4c5/Untitled%203.png)

### 문제점 (무한 계수 문제)

---

**링크 비용 변경** 문제

> **링크의 비용이 증가**하는 경우 문제 발생
>

![Untitled](Control%20Plane%20(%20LS%20,%20DV%20)%200fc463fc1aaf4c0fa3d18ca9e0ebd4c5/Untitled%204.png)

- 라우팅 루프는 잘못된 **동일한 정보가 라우터 간에 계속해서 순환**되는 현상
    - B의 경우  y ↔ x 간의 비용이 증가함에 따라 거리 벡터를 갱신하고 전송하는 과정에서 y와 z 사이의 라우팅 루프 발생
    - **모든 라우팅 정보를 가지는 과정**에서 오랜 수렴 시간 필요

**무한 계수 문제**

> 모든 라우팅 정보를 가지기 위한 수렴 과정에서 도착할 수 없는 네트워크를 도착 가능하다고 잘못 판단한 라우터가 메시지를 생성해 계속 주고 받는 것
>

### 해결 방법 (포이즌 리버스)

---

> 라우팅 테이블에서 **더 이상 사용되지 않을 경로(역경로**)에 대한 **거짓된 정보를 이웃 라우터에게 전송**하여, 해당 경로를 **사용하지 않도록 유도**하는 방식
>
1. z가 y를 통해 목적지 x로 가는 경로 설정을 했다면 z는 y에게 x까지의 거리가 무한대라고 알린다.

2.  z는 y를 통과해서 x로 가는 동안 이러한 거짓말을 지속하게 된다.

1. y는 z에서 x로 가는 경로가 없다고 믿으므로, z가 계속해서 y를 통해 x로 가는 경로를 지나는 동안에는 z를 통하는 경로를 시도하지 않는다.

> 단순히 직접 이웃한 2개의 노드가 아닌 3개 이상의 노드를 포함한 루프는 포이즌 리버스로 감지 불가능
>

## 링크 상태 알고리즘 VS 거리 벡터 라우팅 알고리즘

---

**경로 계산 방법**

- DV : 직접 연결된 이웃과만 메시지 교환 → 최소 비용 추정값을 이웃들에게 제공
- LS : 네트워크 내의 모든 비용 정보를 필요로 한다.

**메시지 복합성**

- DV : 매번 반복마다 직접 연결된 이웃끼리 메세지를 교환
- LS : **O(|N||E|)개의 메세지가 전송**되어야한다. 또한 **링크비용이 변할 때마다** **모든 노드**에게 이를 전달

**수렴 속도**

- LS : O(|N|^2)의 시간 복잡도
- DV : 천천히 수렴 + 라우팅 루프와 무한 계수 문제 발생

**견고성**

- LS : 직접 연결된 링크에 대해 잘못된 비용 정보 브로드캐스트
    - 하나의 링크 상태 노드는 자신의 포워딩 테이블만 계산 → 어느 정도 견고성 제공
- DV : 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있다.
