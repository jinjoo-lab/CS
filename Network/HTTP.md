# HTTP

[노션](https://daisy-atmosphere-561.notion.site/HTTP-9ecee3e5496842b2a35c4499ce280e21?pvs=4)

### 네트워크

> 2대 이상의 컴퓨터를 비롯한 통신 가능한 **기기들을 자원을 공유**할 수 있게 하는 **디지털 통신망**
>

### 질문 - 1

- **네트워크가 존재하는 이유는 뭘까?**

  서로 다른 지역이나 기기에서 컨텐츠를 공유하고 같이 참여할 수 있게하기 위해서이다.

  즉 **애플리케이션**이 즉 네트워크 인프라스트럭처와 수많은 프로토콜의 존재 이유이다.


## 네트워크 애플리케이션

> 하드웨어에 설치하여 사용하고 네트워크를 통해 통신하는 **응용 소프트웨어** ( 게임 , OTT , WEB 등 수많은 형태가 존재한다.)
>
- 다른 위치의 종단 시스템에서 동작하고 네트워크를 네트워크를 통해 통신하는 프로그램을 작성하는 것이다.
- 네트워크 애플리케이션은 2가지 프로그램으로 나눌 수 있다.
    - **서버**
    - **클라이언트**

### 서버 (Server)

> 네트워크를 통해 자원이나 서비스를 제공하는 컴퓨터 시스템
>
- **항상 동작**하고 있는 호스트
- ex : 웹 서버

### 클라이언트 (Client)

> 서버가 제공하는 서비스를 이용하는 장치 or 프로그램
>
- 클라이언트 호스트의 **동작 여부는 필수가 아니다.**
- ex
    - 대표적인 클라이언트 장치 : 스마트폰 , 노트북 , 아이패드
    - 클라이언트 프로그램 : **웹** **브라우저**

### 질문 - 2

- 백엔드 개발자는 애플리케이션의 서버를 개발한다. 즉 네트워크와는 긴밀한 관계라는 것이다. 하지만 **라우터나 링크 계층 코어 장비에서 실행되는 소프트웨어까지는 개발의 범주에 포함되지 않는다. 왜일까?**

  네트워크가 계층 구조이기 때문이다. 그리고 애플리케이션 계층 바깥으로 내보내진 메시지에 대해서는 제어가 불가능하다.

  **??? : 왜 제어가 불가능하죠 ???? ^^;; (알려줄게 기다려 !)**


## 클라이언트 - 서버 구조

> 종단 시스템(호스트)간의 통신을 서버와 클라이언트로 분리시킨 아키텍처
>
- **특징**
    - 클라이언트와 서버는 **요청과 응답**을 주고 받는 관계
    - 클라이언트 - 서버 구조에서 **클라이언트끼리는 직접 통신하지 않는다.**
    - 서버는 **고정 IP**라는 주소를 가진다.

### 프로세스 관점

> 네트워크를 통해 통신에 참여하는 대상은 크게 보면 하드웨어지만 작게 보면 프로세스이다. **프로세스 관점에서 클라이언트 - 서버 구조**를 정의해볼 필요가 있다.
>
- **클라이언트** : 두 프로세스간의 **통신 세션에서 통신을 초기화**하는 프로세스
- **서버** : 통신 세션을 시작하기 위해 **접속을 기다리는** 프로세스

### 소켓

> 소켓은 호스트의 **애플리케이션 계층**과 **전송 계층** 간의 인터페이스
>
- 프로세스들이 보내는 메시지는 네트워크를 통해 움직인다. 그리고 소켓을 통해 메시지를 보내고 받는다.

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/75374653-5287-4303-bf01-a64589d41aa7)

- 즉 소켓에는 2가지 제어 측면이 있다. 애플리케이션 계층쪽과 전송 계층쪽 제어가 있다. 즉 애플리케이션 개발자는 소켓의 애플리케이션 계층 제어(통제)권을 가진다.

### 프로세스의 식별

- 프로세스간 통신에서 패킷(메시지)를 주고받기 위해서는 자신이 누군지 , 즉 프로세스의 식별이 가능해야 한다.
- **IP 주소** : **호스트 식별**
- **포트 번호** :  **호스트에서 수행되는 프로세스(소켓)을 식별**

---

> 네트워크 프로세스는 **소켓으로 통신**한다는 것을 길게 설명했다. 이러한 통신 방식에 대해 깊게 들어갈 준비가 되었다는 것이다.
>

### Application Layer protocol

> 서로 다른 종단 시스템에서 실행되는 **애플리케이션의 프로세스가 서로 메시지를 주고 받는 방법**을 정의한 통신 규약
>
- 애플리케이션 계층의 프로토콜에서는 다음과 같은 것을 정의한다.
    - 교환 메시지 타입
    - 메시지의 형태 , 필드의 의미
    - 언제 전송하고 응답하는지를 결정하는 규칙

### WEB

> (World Wide Web) 인터넷을 통해 연결된 기기들이 정보를 공유하는 애플리케이션
>
- **하이퍼텍스트** 방식으로 인터넷 상의 정보를 정의하고 교류할수 있는 시스템

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/80c9a1bb-de35-4b7e-9edf-1e08754cdd78)

# **Main features of HTTP**

- Client - Server
- 무상태성
- 비연결성

# HTTP (HyperText Transfer Protocol)

> **브라우저**와 **웹 서버** 사이에서 교환되는 메시지의 포맷과 순서를 정의한 웹의 프로토콜
>
- 웹의 애플리케이션 계층 츠로토콜
- HTTP는 클라이언트 프로그램과 서버 프로그램으로 구현된다.
    - **클라이언트 프로그램 : 브라우저**
    - **서버 프로그램 : 웹 서버**
- 서로 다른 종단 시스템에서 작동하는 서버와 클라이언트는 HTTP 메시지를 교환하여 통신한다.
    - 클라이언트 프로그램은 서버 프로그램에 HTTP Request
    - 서버 프로그램은 클라이언트 프로그램에 HTTP Response

> HTTP 프로토콜에서는 근본적으로 클라이언트 - 클라이언트 통신을 지원하지 않는다. 모든 메시지는 클라이언트 - 서버를 통하는 구조여야 한다.
>

### 질문 3 - Why Client - Server

1. **명확성**
- Client - Server 모델은 명확한 역할 분담을 제공한다.
    - Client : 사용자 인터페이스 담당
    - Server : 데이터 처리 및 저장
2. **확장성**
- Client - Server 구조는 서버를 중심으로 하는 구조이다. Client의 크기와 형태는 사실 그닥 중요하지 않는다. 다른 말로 하자면 독립적이다. 즉 서비스 모델의 확장을 고려한다면 Client - Server구조가 적합나다.
3. **웹의 특성** (Resource에 대한 Request And Response)

### URL & URI

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/71fc8d12-4355-4040-bc33-b82218ba929c)

**URL (Uniform Resource Locator)**

> URL은 웹에 게시된 리소스를 검색하기 위해 [브라우저](https://developer.mozilla.org/ko/docs/Glossary/Browser)에서 사용하는 메커니즘 (**자원의 위치 즉 주소**)
>

**URN (Uniform Resource Name)**

> Resource의 위치와 상관없이 식별 가능한 고유한 이름 → 리소스 위치가 변경되더라도 문제없이 동작 (리소스 자체에 부여된 영구적 URI)
>

**URI (Uniform Resource Idenfier)**

> 자원에 대한 고유 식별자 (자원의 위치를 포함한다)
>

## HTTP & TCP

> HTTP는 하위 전송 프로토콜로 **TCP를 사용**한다.
>
- HTTP 클라이언트는 먼저 서버에 TCP 연결 (3way Handshaking)

### 질문 4 - Why TCP

> 위의 질문에서 HTTP는 TCP를 전송 계층 프로토콜로 선택했다. 다양한 이유가 있지만 핵심은 **신뢰성**과 **데이터 순서**이다.
>
- **순서 보장**
    - TCP는 데이터의 전송 순서를 보장 , 이는 웹 페이지나 애플리케이션에서 중요한 요소로, 클라이언트가 서버로 요청을 보내고, 서버가 이에 대한 응답을 순서대로 받아 처리하는 데 유용
- **데이터 보장**
    - TCP는 데이터를 세그먼트로 나누어 전송하고, 수신측에서는 이를 재조립하여 정확한 데이터 전달을 보장 ,  이는 웹에서의 파일 다운로드나 웹 페이지 로딩과 같은 데이터 전송에 적합
- **신뢰성**
    - HTTP는 주로 웹에서 문서 전송에 사용되며, 이를 위해서는 신뢰성 있는 연결

## 무상태성 (Stateless)

- 무상태 프로토콜
    - 동일한 요청을 반복해서 요청하더라도 매번 독립적인 요청으로 처리한다는 것이다.

> 서버는 클라이언트에게 응답하는 과정에 있어 **클라이언트에서 관한 어떤 상태 정보도 저장하지 않는다.** (서버는 클라이언트에 대한 정보를 유지하지 않는다)
>
1. **서버 부하 감소**
- 앞서 설명에서 HTTP는 Client - Server 구조를 체택했고 해당 구조는 서버를 중심으로 돌아간다. 즉 **모든 데이터 처리에 대해 서버를 통한다는 것**이다. 서버에서 모든 요청(Client)에 대한 정보를 유지한다면 ?
    - 지속적으로 상태를 갱신하고 유지하는 과정에서 많은 비용이 발생
2. **확장성**
- 서버가 클라이언트의 상태를 유지하지 않는다는 것은 각각의 요청이 **독립적**이라는 것이다 !
- 즉 모든 요청을 독립적으로 처리하기 때문에 확장이 쉽다.
3. **스케일 아웃**

> 물리적 인스턴스를 늘려서 **분산된 환경**을 구축하는 방식
>
- 스케일 아웃에서는 분산에 따른 Side Effect를 조율하는 것이 중요하다.
- 서버가 클라이언트의 상태를 전부 유지한다면 분산 시에도 해당 상태까지 이전해야 한다.

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/ed34cd39-d922-49cb-a39a-e9956f81bfd6)

- **만약 클라이언트의 상태를 유지해야 한다면?**

  **웹 브라우저의 쿠기** , **서버의 세션** 기술을 이용하면 된다.


## **비연결성 (Connectionless)**

> 많은 찍어내기 (Ctrl + v) 블로그에서 HTTP의 특성 중 하나로 Connectionless를 말한다. 사실 **‘HTTP는 완벽한 Connectionless’**라는 말은 올바르지 않다.
>

### Connection - oriented

> **Client의 요청**에 대한 **Server의 응답** 이후에도 연결은 유지된다. (서버 측에 지속적 부하 발생)
>
- TCP / IP의 경우 기본적으로 연결을 지속적으로 유지한다.

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/08df8725-7be9-4c39-bdaa-1bc0489126a1)

### Connectionless

> **Client의 요청**에 대한 **Server의 응답** 이후에는 연결이 종료된다.
>
- 서버의 부하를 줄일 수 있고 서버 자원에 대한 관리가 효율적이다.

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/6d83565f-9fc0-47be-baec-9565ad1b4f08)

**Connectionless의 한계 (비지속 연결 : non - persistent connection)**

1. 하나의 요청에 대한 하나의 응답에 대해 매번 **TCP연결이 발생**한다.
- TCP 버퍼와 TCP 변수가 양쪽에서 매번 유지 → 서버에 부하 발생
2. 응답에 대해 **2RTT**가 필요하다.

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/87808222-36e6-46e1-b1f1-9c5aba03feb6)

### Persistent - Connection (지속 연결)

> 서버는 응답을 보낸 후에 **TCP연결을 그대로 유지**한다. (HTTP/1.1 부터 상용화)
>
- 같은 클라이언트와 서버 간의 이후 요청과 응답은 동일한 TCP Connection을 통해 지속
- **타임 아웃을 적용**하여 일정 기간 요청-응답이 이루어지지 않는다면 해당 연결을 닫는다.

### 파이프라이닝

- HTTP의 요청에 대한 응답은 순차적으로 처리되어야 한다. 1,2,3 의 요청에 대해 1이 처리되고 2가 처리되고… 이러한 과정은 다음 요청에 대한 **지연 시간이 발생**한다.

> 하나의 Connection에서 응답을 기다리지 않고 순차적으로 여러 요청을 연속적으로 보내 순서에 밫줘 응답을 받는 방식
>

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/4139d61a-db69-40a3-adbf-bf64b30556b0)

### HOL Blocking (Head Of Line Blocking)

> 패킷을 전송하고 싶은데 이전 **패킷을 전송하는데 지연이 발생**해 패킷을 전송하지 못하는 상황
>
- 패킷 1에 대한 처리는 5초가 소요되고 패킷 2에 대한 처리는 1초가 소요된다. 결국 패킷 1이 먼저 처리되야 하므로 요청을 연속적으로 보내도 패킷 2에 대한 전송은 이상적으로 처리되지 않는다.

## HTTP 메시지

> 앞서 말했듯 HTTP는 요청과 응답으로 구분된다. 그리고 서버와 클라이언트 사이에는 메시지를 교환한다.
>

### Request

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/99b38726-93be-4f91-abf4-cdcab6512b35)

1. Request Line
- Method Field , URL 필드 , HTTP 버전 필드
2. Header Line
- Header Filed Name : Value 형식
3. Body Line
- 사용자가 데이터를 담을 때 사용

### Response

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/fff50bf3-abd6-4e42-aff4-d6ed21a908a4)

1. Status Line
- HTTP 버전 , 상태 코드 , 상태 코드에 대한 설명
2. Header Line
- Header Filed Name : Value 형식
3. Body Line
- 서버가 사용자 요청에 대한 데이터를 담을 때 사용

### 멱등성 : Method Field

> 동일한 요청을 **한번 보내는 것**과 여러 번 **연속으로 보내는 것**이 같은 효과를 지니고 **서버의 상태도 동일하게 남는 것**
>
- 멱등성이란 **side effect**가 발생해서는 안된다.
- 멱등성 보장
    - **`GET, PUT, DELETE`**
- 멱등성 비보장
    - **`POST`**

### PUT & PATCH

> PUT과 PATCH 메소드 전부 리소스의 업데이트에 사용된다. 하지만 업데이트의 의도와 방식에 차이가 있다.
>
- PUT
    - PUT은 주어진 URI에 해당하는 리소스를 업데이트하거나, 존재하지 않는 경우에는 새로운 리소스를 생성
    - 완전 대체의 경우 주로 사용 (리소스에 대한 전체 표현이 요구된다)

```
PUT /users/123
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30
}
```

- PATCH
    - 부분 업데이트 : 클라이언트는 업데이트하고자 하는 리소스의 일부만 제공

```
PATCH /users/123
Content-Type: application/json

{
  "age": 31
}
```

> RFC 5789가 2010년에 출판되면서 **PATCH 메서드의 사용에 대한 명세가 명확화**되었습니다. 이 RFC는 "HTTP Patch Method"라는 제목으로 PATCH 메서드에 대한 설명을 추가했으며, 그 중에서도 멱등성에 대한 내용이 포함되었습니다. RFC 5789에서는 **PATCH 메서드가 멱등성을 가져야 한다고 명시**
>

## Status Code

> 요청에 대한 응답 결과를 나타내는 3자리 숫자
>

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/a3a82c24-af75-4ac4-aaec-6792d476061f)

### 1XX

> 요청을 받았으며 프로세스를 계속 진행한다는 코드 (HTTP 1.0에서는 지원되지 않았다.)
>
- **나는 한번도 1xx번대를 본적이 없는걸?**

  말 그대로 요청을 받았고 계속 진행하겠다는 코드이다. 요청에 대한 처리 후 응답시 포함되는 상태 코드에 1xx번대가 포함되는 일은 흔하지 않다.

    1. 요청의 처리 지연
    2. 요청 분할 - 순차 처리

### 2XX

> 요청의 성공적 처리를 알린다.
>

**200 OK**

- 요청이 성공적으로 처리. 정보는 요청에 따른 응답으로 반환

**201 Created**

- 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성
- POST 요청 또는 일부 PUT 요청

**202 Accepted**

> 요청을 수신하였지만, 그에 응하여 행동할 수 없습니다. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않습니다. 이것은 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌습니다.
>

**203 Non-Authoritative Information**

- 응답받은 메타 정보 세트가 오리진 서버의 것과 일치하지 않지만 로컬이나 서드 파티 복사본에서 모아졌음을 의미

**204 No Content**

- 요청에 대해서 보내줄 수 있는 콘텐츠가 없지만, 헤더는 의미있을 수 있다

### 3XX

> 응답에 대한 추가적인 처리 동작이 필요하다. **( Redirection messages )**
>

**301 Moved Permanently**

- 요청한 리소스의 URI가 변경되었음을 의미 , 새로운 URI가 응답에서 아마도 주어질 수 있습니다.

**302 Found**

- 요청한 리소스의 URI가 일시적으로 변경되었음을 의미합니다. 새롭게 변경된 URI는 나중에 만들어질 수 있습니다. 그러므로, 클라이언트는 향후의 요청도 반드시 동일한 URI로 해야합니다.’

**304 Not Modified**

- 이것은 캐시를 목적으로 사용됩니다. 이것은 클라이언트에게 응답이 수정되지 않았음을 알려주며, 그러므로 클라이언트는 계속해서 응답의 캐시된 버전을 사용

![image](https://github.com/jinjoo-lab/SSAFY_CS_Study/assets/84346055/8905e324-3116-4749-b99c-29a6c7a05121)

### 4XX ( Client Error Responses)

> 클라이언트의 요청이 잘못되었다. (니 잘못)
>

**400 Bad Request**

- 잘못된 문법으로 인하여 서버가 요청하여 이해할 수 없음
- 예시 : 잘못된 요청 형식, 필수 요청 매개변수 누락, 잘못된 헤더 등

**401 Unauthorized**

- 인증되지 않은 사용자에 대한 요청

**403 Forbidden**

- 해당 리소스에 대한 권한이 없다

**404 Not Found**

- 서버는 요청받은 리소스를 찾을 수 없다.
- 예시 : 존재하지 않는 페이지에 대한 요청, 삭제된 리소스에 대한 요청

### 5XX (Server Error Responses)

> 서버의 처리에 있어 오류가 발생했다. (내 잘못)
>

[HTTP 상태 코드 정리 | 와탭 블로그](https://www.whatap.io/ko/blog/40/)
