# 데이터 평면 - 라우터

### 네트워크 계층

> **호스트들간의 논리적 통신을 제공**하는 네트워크 계층
>
- 상호작용하는 **데이터 평면**과 **제어 평면**으로 나눌 수 있다.

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled.png)

### 데이터 평면 요약

1. 라우터 별 제어
2. IP 포워딩 + 일반화된 포워딩
3. IPv4 / IPv6

> 네트워크 계층의 역할을 좀 더 구체적으로 표현하자면 **송신 측은 전송 계층의 세그먼트를 데이터그램으로 캡슐화하여 전송하고 수신 측은 세그먼트를 추출하여 전송 계층으로 전달**한다.
>
- 데이터 평면 : **입력링크에서 출력링크로 데이터그램을 전달**한다. (포워딩)
    - HW에서 수행
- 제어 평면 : 출발지 호스트에서 목적지 호스트까지 데이터그램의 전달 즉 **패킷 경로를 결정**한다. (라우팅)
    - 라우팅 알고리즘 : 패킷 경로를 계산하는 알고리즘
    - SW에서 수행

### 포워딩 테이블

> 패킷의 헤더값을 추출하고, 그 값을 바탕으로 라우터 내부의 다양한 출력 링크 중 어떤 링크로 패킷을 이동시킬지 결정해주는 테이블
>

### 네트워크 서비스 모델

> **송수신 호스트 간 패킷 전송의 특성**을 정의하고 다음과 같은 특성을 포함한다.
>
1. 보장된 전달
2. 지연 제한 이내 보장된 전달
3. 순서화된 패킷 전달
4. 최소대역폭 보장
5. 보안 서비스

### 인터넷 네트워크 계층

- IP 프로토콜
- **최선형 서비스**를 추구한다.
    - 순서가 보장되지 않는다.
    - 목적지까지의 전달이 보장되지 않는다.
    - 지연 제한 이내 전달이 보장되지 않는다.
    - 최소 대역폭이 보장되지 않는다.

### 이유

1. **유연성과 확장성**
    - 최선형 서비스를 제공하는 것은 네트워크의 유연성과 확장성을 향상
    - 다양한 종류의 트래픽과 다양한 응용 프로그램에 대한 지원이 가능하며, 새로운 기술과 서비스를 쉽게 통합.
2. **경제적 효율성**
    - 최선형 서비스는 구현 및 유지 관리가 비교적 간단하며, 비용 효율적
    - 다양한 유형의 데이터 트래픽에 대한 서비스 품질을 보장하려면 특정 유형의 트래픽을 처리하는 복잡한 시스템이 필요하게 될 것이며, 이는 더 높은 비용과 복잡성을 초래
3. **다양한 사용 사례 지원**
    - 최선형 서비스는 다양한 사용 사례와 응용 프로그램을 지원

### 라우터

1. 입력 포트
    - 물리 + 링크 계층의 기능을 수행
    - **검색 기능 ( 포워딩 테이블을 참조하여 라우터의 출력 포트를 결정 )**
2. 스위치 구조
    - 메모리
    - 버스
    - 상호연결 네트워크
3. 출력 포트
4. 라우팅 프로세서 - 제어 평면의 영역 ( 라우팅 알고리즘 수행 )

### 입력 포트 : 목적지 기반 포워딩

> 목적지 IP 주소를 기반으로 수행
>
- 포워딩 테이블
    - 라우터는 **패킷의 목적지 주소의 Prefix**를 테이블 엔트리에 매치시킨다.
    - 다수의 매치가 발생할 수 있고 이 경우에는 **최장 프리픽스 매치 규칙**을 따른다.
- 포워딩 테이블에서 검색은 결국 선형적 탐색의 특징을 가진다.
    - 한계를 극복하기 위해 메모리 접근 시간을 줄이기 위해 DRAM이나 SRAM등의 메모리를 사용한다.

> 입력포트에서 검색을 완료하고 출력포트가 결정되었다면 패킷은 스위치로 전달된다.
>

## 패킷 스위치 방식

- 메모리
- 버스
- 상호 연결 네트워크

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled%201.png)

### 메모리 방식

> **라우터가 라우팅 프로세서를 직접 제어 패킷을 스위칭한**다. (입력 포트와 출력 포트 사이에서 패킷 스위칭)
>
- 동작 방식
    1. 입력포트는 라우팅 프로세스에게 인터럽트를 보냄
    2. 패킷을 프로세서 메모리에 복사
    3. 라우팅 프로세서는 헤더에서 목적지주소 추출 + 포워딩 테이블에서 출력 포트를 찾고 패킷을 출력 포트의 버퍼에 복사
- 단점
    - 공유 시스템 버스를 통해 한번에 하나의 I/O 가능 → **패킷의 동시 전달 불가능**
    - **Speed Limit** : 메모리 대역폭 / 2

### 버스 방식

> 입력 포트는 **라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷 전송**
>
- 입력 포트 스위치 내부 레이블 (식별자) → 버스를 통해 출력 포트에 도착 시 레이블이 일치하는 패킷만 유지
- 단점
    - **버스 속도에 따라 성능이 제한**된다.
    - 한번에 하나의 패킷만 버스 통과 가능 → **패킷의 동시 전달 불가능**

### 상호 연결 네트워크

> 입력 포트와 출력 포트 사이에 **다수의 버스를 상호 연결 네트워크**로 구성
>
- 크로스바 스위치 ( 2N개의 버스로 구성 )
    - 수직 버스는 수평 보스와 교차하여 스위치 구조 컨트롤러에 의해 열리거나 닫힘
    - **여러 패킷을 동시에 병렬 전달 가능 ( 단 출력 포트가 달라야 한다 !!!! )**
- 다단계 스위치 구조 ( N * N )
    - 서로 다른 입력 포트의 패킷이 동일한 출력 포트로 동시에 전달 가능
    - 다중 스위치 구조를 병렬로 실행하여 확장 가능
        - 패킷을 청크 단위로 분할 전달 → 출력 포트에서 패킷으로 제조

## 출력 포트

> 츨력 포트의 메모리에 저장된 패킷을 출력 링크를 통해 전달
>

---

## 큐잉

> 패킷이 이동하는 경로는 라우터에서 **입력 포트**와 **출력 포트**이다. 즉 여러 패킷이 들어올 때 해당 패킷 큐에서는 큐잉 즉 버퍼 관리가 필요하다.
>

### 입력 큐잉

> Switch fabric이 input 포트보다 느리면
>
- 크로스바 스위치를 통해 우리는 서로 다른 출력 포트로 향하는 패킷에 대해 동시 처리가 가능해졌다.
- 두 패킷이 같은 출력 큐로 향한다면 한 패킷은 차단되고 입력 큐에서 대기하게 된다.
- HOL - Blocking
    - **라인의 앞쪽에서 다른 패킷이 대기 상태에 있어** 입력 큐에서 대기중인 패킷이 **출력 포트가 사용중이지 않아도** 스위치 구조를 통해 전송되기 위해 **대기**해야 하는 현상

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled%202.png)

### 출력 큐잉

> Switch fabric보다 output line 속도가 느린 경우
>
- **출력 포트는 시간 단위에 단일 패킷만 전송**하기 때문에 N개의 도착 패킷은 **출력 링크를 통한 전송 큐**에서 다시 대기
- 이 과정에서 패킷을 저장할 메모리가 충분하지 않은 경우 도착한 패킷을 삭제하거나 대기 중인 패킷을 제거 → 패킷 손실
    - 명시적 혼잡 알림 ( ECN )
    - AQM 알고리즘 ( 패킷 삭제 + 패킷 마킹 )

## 패킷 스케줄링

> 큐에 있는 패킷이 출력 링크를 통해 전송되는 순서를 결정
>
- FIFO  / FCFS
- 우선순위 큐잉
- 라운드 로빈 큐잉

### FCFS

> 출력 링크 큐에 **도착한 순서와 동일한 순서**로 출력 링크에서 전송할 패킷을 선택
>

### 우선순위 큐잉

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled%203.png)

- 출력 링크 큐에 도착한 **패킷은 우선순위 클래스**로 분류
    - 우선순위에 따라 고유한 큐로 분류
    - 기징 넢은 우선순위 클래스에서 패킷을 전송
        - 같은 우선순위 큐 내에서는 FIFO 방식 사용
- **비선점 우선순위 큐잉**
    - 패킷의 전송이 시작되면 중간에 더 큰 우선순위의 패킷이 들어오더라도 전송을 중단하지 않는다.

### 라운드 로빈

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled%204.png)

- 패킷은 클래스로 분류 ( 엄격한 서비스 우선순위가 존재하지는 않는다. )
- **라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아가 제공**
- 작업 보존 큐잉 규칙
    - 전송을 위해 큐에서 기다리는 패킷이 있다면 링크가 유후 상태가 되는 것을 혀용하지 않는다.
    - 해당 클래스에 패킷이 없다면 시퀀스의 다음 클래스 검사

### WFQ (Weighted Fair Queuing)

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A7%E1%86%AB%20-%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%90%E1%85%A5%2017577e103f8c4654a079fb6d9c454d0a/Untitled%205.png)

- 라우터에서 라운드 로빈 큐잉의 일반화된 형태 , 패킷은 적절한 **클래스별 대기 영역에 분류**되며 대기
- WFQ 스케줄러는 순환 방식으로 동작
    - 각 **클래스마다 다른 양의 서비스 시간을 부가**한다.
    - 각 클래스는 가중치를 할당받는다.
    - 각 클래스는 가중치에 따라 서비스 시간을 보장받는다.
- 혼잡 제어를 위한 큐잉 매커니즘
    - 소량의 트래픽이 대량의 트래픽에 의해 손해를 보지 않도록 **서비스 시간(대역폭)을 보장**한다.
