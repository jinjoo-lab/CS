# Redis Init

## Redis

---

> **키 - 값 유형**의 **인메모리** NoSQL 데이터베이스 (오픈 소스 기반의 데이터 저장소)
>

### 인메모리 데이터베이스

- 모든 데이터가 **컴퓨터의 메모리**에서 관리
    - 디스크에 접근하는 과정이 없기 때문에 데이터의 처리 성능이 굉장히 빠르다.
- 기본적으로 데이터의 영속성을 보장하지 않는다.

### 온디스크 데이터베이스

- 데이터는 영구적으로 **디스크**에 저장
    - 자주 사용되는 데이터 → 캐싱되어 메모리에 올라와 있음
    - 데이터 접근 시 디스크를 접근하는 과정이 필요하다 (Random I/O)
- 디스크는 주로 HDD, SSD
    - 디스크에 접근하는 **빈도가 증가**할수록 **시스템의 성능은 저하**

### 단순성

- 레디스는 키 - 값 형태로 데이터를 관리할 수 있는 데이터 저장소
- 키에 매핑되는 값은 문자열, Hash, Set 등 **다양한 데이터 구조 지원**

> **임피던스 불일치**를 해소 가능
데이터베이스 테이블과 프로그래밍 언어간 데이터 구조 차이로 인해 발생하는 충돌
>

### 스레드

---

> **클라이언트의 커맨드를 처리**하는 부분은 이벤트 루프를 이용한 **싱글 스레드로 동작**
>
> - 사용자의 요청은 순차적으로 처리된다.
- Redis는 싱글 스레드로 동작 (정확히는 메인 스레드 1개와 별도의 스레드 3개로 동작)
    - Redis 6.0 이상부터는 일부 **백그라운드 작업에 대해 I/O 스레드 풀**을 사용
    - 나머지 쓰레드들은 Disk를 flush하거나 파일을 닫기 위한 OS 작업등 → OS 레벨에서 비동기로 동작

**싱글 스레드 ?**

> 멀티스레드 애플리케이션에서 요구되는 **동기화**나 **잠금 매커니즘**이 없이도 안정적이고 빠르게 요청 처리
대부분의 Redis 작업은 단일 작업으로 처리
>
1. **단순성**: 단일 작업은 하나의 명령어 또는 작업으로 이루어지기 때문에 복잡한 동시성 제어나 동기화 문제를 다룰 필요가 없습니다. 이로 인해 구현이 단순해지고 버그가 줄어듭니다.
2. **직렬화와 일관성 유지**: 단일 스레드가 작업을 순차적으로 처리하기 때문에 여러 작업 간에 일관성을 유지하기 쉽습니다. 작업 간의 경합 조건이나 동시성 문제를 고려할 필요가 없어집니다.
3. **자원 공유 문제 회피**: 여러 스레드가 동일한 자원에 접근할 때 발생하는 경합 조건과 자원 공유 문제를 회피할 수 있습니다. 단일 스레드에서는 자원에 대한 접근을 직렬화하기 때문에 이러한 문제가 발생하지 않습니다.
4. **오버헤드 감소**: 멀티 스레드나 멀티 프로세스 모델에서는 스레드 간의 문맥 전환 비용이나 동기화에 필요한 추가적인 오버헤드가 발생할 수 있습니다. 하지만 단일 스레드에서는 이러한 오버헤드가 없거나 매우 적습니다.
5. **성능 최적화**: 단일 스레드 모델은 작업을 순차적으로 처리하기 때문에 CPU 캐시 활용과 관련된 성능 최적화가 더 쉽습니다. 또한 메모리 접근 지역성이 높아져 캐시 효율이 향상될 수 있습니다.

### Race Condition

---

### Redis Event Loop : I/O Multiplexing

> Redis의 클라이언트 처리를 하는 **싱글 스레드**에서는 **Event Loop 방식**으로 처리
>

![Untitled](Redis%20Init%20ada9d50068a44b11b4f334cc2182e6e7/Untitled.png)

> 하나의 통신 채널을 통해 대량의 데이터를 전송하는 기술
>
- **한 개의 프로세스**나 **스레드**를 이용하여 작업을 처리
- **한 개의 스레드를 사용**하지만 **많은 양의 소켓 커넥션**을 대기 할 수 있도록 한다.

> 나의 스레드에서 다수의 클라이언트에 연결된 소켓(파일 디스크립터)을 관리하면서 소켓에 이벤트(read/write)가 발생할 때만 해당 이벤트를 처리하도록 구현함
>

### 동작 방식

1. **새 클라이언트가 Redis에 연결**되면 **이벤트 루프에 등록**되고 이벤트 루프는 들어오는 데이터에 대한 연결을 모니터링합니다.
2. 클라이언트로부터 데이터가 도착하면 **이벤트 루프는 이벤트 유형을 결정**하고 그에 따라 처리합니다.
3. 클라이언트의 요청에 **I/O작업이 필요한 경우** 이벤트 루프는 다른 클라이언트의 연결의 진행을 차단하지 않고 작업을 **비동기적으로 수행**합니다.
4. 이벤트 루프가 여러 클라이언트의 이벤트를 처리할 때 각 클라이언트에 대해 **보류 중인 작업 대기열을 유지 관리**합니다. 이를 통해 Redis는 실제 처리가 단일 스레드 내에서 발생하더라도 동시에 여러 클라이언트에 서비스를 제공할 수 있습니다.

### 고가용성

> **센티널**
>
- 복제를 통해 데이터를 여러 서버에 분산 가능
- 센티널은 장애 상황을 탐지 → 자동으로 Fail Over
    - 마스터에 장애가 발생하더라도 레디스로의 엔드포인트를 변경할 필요 없이 페일 오버 완료

### 확장성

> **클러스터 모드**
>
- 레디스의 클러스터 모드 → 수평적 확장 가능
- 데이터는 **레디스 클러스터** 내에서 자동으로 **샤딩**된 후 저장 → 여러 개의 복제본 생성 가능
- 클러스터 모드에서 모든 레디스 인스턴스 → **클러스터 버스 프로토콜** 사용
    - 마스터 노드에 문제 발생 → 자동으로 페일 오버

## MSA에서 Redis

---

## 데이터 저장소로서의 레디스

> 기본적으로 In-Memory 구조의 Redis는 영속성을 보장하지 않는다. 하지만 Redis를 사용하면서 영속성을 유지할 수 있는 방법이 아예 없는 것은 아니다.
>
- 메모리에 저장되는 구조이기 때문에 **AOF**, **RDB** 형식으로 디스크에 주기적으로 저장 가능

### RDB(Snapshotting)

> 주기적으로 **디스크 기반에 데이터베이스**에 접근하여 **Redis의 상태를 옮겨 저장**하는 방식
>
- Redis의 데이터를 동기화하는 동안 Blocking을 고려해야 한다.

### AOF(Append - Only File)

> Redis에 작동하는 모든 **Write/Update 연산**을 별도의 **로그 파일에 기록**
>

## 메시지 브로커로서의 레디스

- 레디스의 **PUB/SUB** 기능
    - 간단하고 빠르게 동작 가능
    - 모든 데이터는 전달된 뒤 삭제되는 **일회성**
- 레디스의 List 자료구조
    - 데이터를 빠르게 push/pop 가능
- 레디스의 stream 자료구조
